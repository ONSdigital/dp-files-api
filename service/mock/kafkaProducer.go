// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"context"
	"github.com/ONSdigital/dp-files-api/service"
	"github.com/ONSdigital/dp-healthcheck/healthcheck"
	kafka "github.com/ONSdigital/dp-kafka/v3"
	"github.com/ONSdigital/dp-kafka/v3/avro"
	"sync"
)

// Ensure, that OurProducerMock does implement service.OurProducer.
// If this is not the case, regenerate this file with moq.
var _ service.OurProducer = &OurProducerMock{}

// OurProducerMock is a mock implementation of service.OurProducer.
//
// 	func TestSomethingThatUsesOurProducer(t *testing.T) {
//
// 		// make and configure a mocked service.OurProducer
// 		mockedOurProducer := &OurProducerMock{
// 			ChannelsFunc: func() *kafka.ProducerChannels {
// 				panic("mock out the Channels method")
// 			},
// 			CheckerFunc: func(ctx context.Context, state *healthcheck.CheckState) error {
// 				panic("mock out the Checker method")
// 			},
// 			CloseFunc: func(ctx context.Context) error {
// 				panic("mock out the Close method")
// 			},
// 			InitialiseFunc: func(ctx context.Context) error {
// 				panic("mock out the Initialise method")
// 			},
// 			IsInitialisedFunc: func() bool {
// 				panic("mock out the IsInitialised method")
// 			},
// 			LogErrorsFunc: func(ctx context.Context)  {
// 				panic("mock out the LogErrors method")
// 			},
// 			SendFunc: func(schema *avro.Schema, event interface{}) error {
// 				panic("mock out the Send method")
// 			},
// 		}
//
// 		// use mockedOurProducer in code that requires service.OurProducer
// 		// and then make assertions.
//
// 	}
type OurProducerMock struct {
	// ChannelsFunc mocks the Channels method.
	ChannelsFunc func() *kafka.ProducerChannels

	// CheckerFunc mocks the Checker method.
	CheckerFunc func(ctx context.Context, state *healthcheck.CheckState) error

	// CloseFunc mocks the Close method.
	CloseFunc func(ctx context.Context) error

	// InitialiseFunc mocks the Initialise method.
	InitialiseFunc func(ctx context.Context) error

	// IsInitialisedFunc mocks the IsInitialised method.
	IsInitialisedFunc func() bool

	// LogErrorsFunc mocks the LogErrors method.
	LogErrorsFunc func(ctx context.Context)

	// SendFunc mocks the Send method.
	SendFunc func(schema *avro.Schema, event interface{}) error

	// calls tracks calls to the methods.
	calls struct {
		// Channels holds details about calls to the Channels method.
		Channels []struct {
		}
		// Checker holds details about calls to the Checker method.
		Checker []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// State is the state argument value.
			State *healthcheck.CheckState
		}
		// Close holds details about calls to the Close method.
		Close []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// Initialise holds details about calls to the Initialise method.
		Initialise []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// IsInitialised holds details about calls to the IsInitialised method.
		IsInitialised []struct {
		}
		// LogErrors holds details about calls to the LogErrors method.
		LogErrors []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// Send holds details about calls to the Send method.
		Send []struct {
			// Schema is the schema argument value.
			Schema *avro.Schema
			// Event is the event argument value.
			Event interface{}
		}
	}
	lockChannels      sync.RWMutex
	lockChecker       sync.RWMutex
	lockClose         sync.RWMutex
	lockInitialise    sync.RWMutex
	lockIsInitialised sync.RWMutex
	lockLogErrors     sync.RWMutex
	lockSend          sync.RWMutex
}

// Channels calls ChannelsFunc.
func (mock *OurProducerMock) Channels() *kafka.ProducerChannels {
	if mock.ChannelsFunc == nil {
		panic("OurProducerMock.ChannelsFunc: method is nil but OurProducer.Channels was just called")
	}
	callInfo := struct {
	}{}
	mock.lockChannels.Lock()
	mock.calls.Channels = append(mock.calls.Channels, callInfo)
	mock.lockChannels.Unlock()
	return mock.ChannelsFunc()
}

// ChannelsCalls gets all the calls that were made to Channels.
// Check the length with:
//     len(mockedOurProducer.ChannelsCalls())
func (mock *OurProducerMock) ChannelsCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockChannels.RLock()
	calls = mock.calls.Channels
	mock.lockChannels.RUnlock()
	return calls
}

// Checker calls CheckerFunc.
func (mock *OurProducerMock) Checker(ctx context.Context, state *healthcheck.CheckState) error {
	if mock.CheckerFunc == nil {
		panic("OurProducerMock.CheckerFunc: method is nil but OurProducer.Checker was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		State *healthcheck.CheckState
	}{
		Ctx:   ctx,
		State: state,
	}
	mock.lockChecker.Lock()
	mock.calls.Checker = append(mock.calls.Checker, callInfo)
	mock.lockChecker.Unlock()
	return mock.CheckerFunc(ctx, state)
}

// CheckerCalls gets all the calls that were made to Checker.
// Check the length with:
//     len(mockedOurProducer.CheckerCalls())
func (mock *OurProducerMock) CheckerCalls() []struct {
	Ctx   context.Context
	State *healthcheck.CheckState
} {
	var calls []struct {
		Ctx   context.Context
		State *healthcheck.CheckState
	}
	mock.lockChecker.RLock()
	calls = mock.calls.Checker
	mock.lockChecker.RUnlock()
	return calls
}

// Close calls CloseFunc.
func (mock *OurProducerMock) Close(ctx context.Context) error {
	if mock.CloseFunc == nil {
		panic("OurProducerMock.CloseFunc: method is nil but OurProducer.Close was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	return mock.CloseFunc(ctx)
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//     len(mockedOurProducer.CloseCalls())
func (mock *OurProducerMock) CloseCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// Initialise calls InitialiseFunc.
func (mock *OurProducerMock) Initialise(ctx context.Context) error {
	if mock.InitialiseFunc == nil {
		panic("OurProducerMock.InitialiseFunc: method is nil but OurProducer.Initialise was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockInitialise.Lock()
	mock.calls.Initialise = append(mock.calls.Initialise, callInfo)
	mock.lockInitialise.Unlock()
	return mock.InitialiseFunc(ctx)
}

// InitialiseCalls gets all the calls that were made to Initialise.
// Check the length with:
//     len(mockedOurProducer.InitialiseCalls())
func (mock *OurProducerMock) InitialiseCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockInitialise.RLock()
	calls = mock.calls.Initialise
	mock.lockInitialise.RUnlock()
	return calls
}

// IsInitialised calls IsInitialisedFunc.
func (mock *OurProducerMock) IsInitialised() bool {
	if mock.IsInitialisedFunc == nil {
		panic("OurProducerMock.IsInitialisedFunc: method is nil but OurProducer.IsInitialised was just called")
	}
	callInfo := struct {
	}{}
	mock.lockIsInitialised.Lock()
	mock.calls.IsInitialised = append(mock.calls.IsInitialised, callInfo)
	mock.lockIsInitialised.Unlock()
	return mock.IsInitialisedFunc()
}

// IsInitialisedCalls gets all the calls that were made to IsInitialised.
// Check the length with:
//     len(mockedOurProducer.IsInitialisedCalls())
func (mock *OurProducerMock) IsInitialisedCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockIsInitialised.RLock()
	calls = mock.calls.IsInitialised
	mock.lockIsInitialised.RUnlock()
	return calls
}

// LogErrors calls LogErrorsFunc.
func (mock *OurProducerMock) LogErrors(ctx context.Context) {
	if mock.LogErrorsFunc == nil {
		panic("OurProducerMock.LogErrorsFunc: method is nil but OurProducer.LogErrors was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockLogErrors.Lock()
	mock.calls.LogErrors = append(mock.calls.LogErrors, callInfo)
	mock.lockLogErrors.Unlock()
	mock.LogErrorsFunc(ctx)
}

// LogErrorsCalls gets all the calls that were made to LogErrors.
// Check the length with:
//     len(mockedOurProducer.LogErrorsCalls())
func (mock *OurProducerMock) LogErrorsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockLogErrors.RLock()
	calls = mock.calls.LogErrors
	mock.lockLogErrors.RUnlock()
	return calls
}

// Send calls SendFunc.
func (mock *OurProducerMock) Send(schema *avro.Schema, event interface{}) error {
	if mock.SendFunc == nil {
		panic("OurProducerMock.SendFunc: method is nil but OurProducer.Send was just called")
	}
	callInfo := struct {
		Schema *avro.Schema
		Event  interface{}
	}{
		Schema: schema,
		Event:  event,
	}
	mock.lockSend.Lock()
	mock.calls.Send = append(mock.calls.Send, callInfo)
	mock.lockSend.Unlock()
	return mock.SendFunc(schema, event)
}

// SendCalls gets all the calls that were made to Send.
// Check the length with:
//     len(mockedOurProducer.SendCalls())
func (mock *OurProducerMock) SendCalls() []struct {
	Schema *avro.Schema
	Event  interface{}
} {
	var calls []struct {
		Schema *avro.Schema
		Event  interface{}
	}
	mock.lockSend.RLock()
	calls = mock.calls.Send
	mock.lockSend.RUnlock()
	return calls
}
